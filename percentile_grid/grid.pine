//@version=6
bool useCustomRange     = input.bool(false, "启用自定义回测区间")
int  rangeStartYear     = input.int(2020, "回测开始年份", minval = 1970, maxval = 2100)
int  rangeStartMonth    = input.int(1, "回测开始月份", minval = 1, maxval = 12)
int  rangeStartDay      = input.int(1, "回测开始日期", minval = 1, maxval = 31)
int  rangeEndYear       = input.int(2030, "回测结束年份", minval = 1970, maxval = 2100)
int  rangeEndMonth      = input.int(12, "回测结束月份", minval = 1, maxval = 12)
int  rangeEndDay        = input.int(31, "回测结束日期", minval = 1, maxval = 31)

int rangeStart = useCustomRange ? timestamp(rangeStartYear, rangeStartMonth, rangeStartDay, 0, 0) : na
int rangeEnd   = useCustomRange ? timestamp(rangeEndYear, rangeEndMonth, rangeEndDay, 23, 59) : na
bool inRange   = not useCustomRange or (time >= rangeStart and time <= rangeEnd)

strategy("BTC 日K分位数 + 小时网格策略 v6",
     overlay = true,
     initial_capital = 100000,
     default_qty_type = strategy.percent_of_equity,
     default_qty_value = 100,
     max_bars_back = 5000,
     pyramiding = 100,
     calc_on_every_tick = true)

//=== 参数 ===//
windowDays   = input.int(600,     "日K分位数窗口 (天)", minval = 60, maxval = 2000)
minPct       = input.float(5.0,  "全仓所对应的最低分位数%", minval = 0.0, maxval = 50.0)
stepPct      = input.float(10.0,  "每下降多少分位数增加一份仓位%", minval = 1.0, maxval = 50.0)
gridCount    = input.int(10,      "总网格数", minval = 1, maxval = 200)

// 自动计算仓位份数：从 100% 分位跌到 minPct 分位，一共多少档
numTranches = math.max(1, math.round((100.0 - minPct) / stepPct))
float totalCapital = strategy.initial_capital + strategy.netprofit
float totalQty = close > 0 and not na(close) ? totalCapital / close : 0.0
trancheQty  = totalQty / numTranches

//=== 在日线级别计算分位数 ===//
// 在日线上下文里计算：过去 windowDays 根日K中，有多少收盘价 <= 当前收盘价
f_daily_percentile(int length) =>
    float pct = na
    if bar_index >= length
        float cnt   = 0.0
        float valid = 0.0
        for i = 0 to length - 1
            float v = close[i]
            if not na(v)
                valid += 1.0
                if v <= close
                    cnt += 1.0
        pct := valid > 0 ? 100.0 * cnt / valid : na
    pct

// 用 security 把“日线分位数”拉到当前周期
p = request.security(
     syminfo.tickerid,
     "D",
     f_daily_percentile(windowDays),
     barmerge.gaps_off,
     barmerge.lookahead_off)

//=== 根据分位数计算“基础仓位份数” ===//
var float baseTranches = 0.0

if not na(p) and inRange
    if p <= minPct
        baseTranches := numTranches * 1.0
    else if p >= 100
        baseTranches := 0.0
    else
        // 越便宜 (p 小) → (100 - p) 越大 → 持有越多
        bandsFromTop = (100.0 - p) / stepPct
        float rawTr  = math.floor(bandsFromTop)
        rawTr        := math.max(0.0, math.min(numTranches * 1.0, rawTr))
        baseTranches := rawTr

//=== 网格部分：在每个分位区间内用整份仓位做区间网格 ===//

// 当前实际持有的“份数”（整数），当前所处分位区间，以及该区间内的价格上下沿
var int   actualTranches     = 0
var int   currentZone        = 0
var float zoneLowPrice       = na
var float percentileMaxPrice = na

// 当前目标基础份数（四舍五入成整数）
int baseTrInt = math.round(baseTranches)

// 工具函数：按目标份数下单
f_rebalance_to_tranches(int targetTr) =>
    float targetQty = targetTr * trancheQty
    float diff      = targetQty - strategy.position_size
    if diff > 0
        // 需要加仓 diff
        strategy.entry("Long", strategy.long, qty = diff)
    else if diff < 0
        // 需要减仓 |diff|，用反向单减少多头
        strategy.order("ReduceLong", strategy.short, qty = math.abs(diff))

// 如果自定义回测区间结束后还有仓位，立即清仓
bool afterRange = useCustomRange and time > rangeEnd
if afterRange
    if strategy.position_size != 0
        strategy.close("Long")
    actualTranches     := 0
    currentZone        := 0
    zoneLowPrice       := na
    percentileMaxPrice := na

// 初始：第一根 bar 时，把实际份数调到基础份数
if barstate.isfirst
    actualTranches := baseTrInt
    f_rebalance_to_tranches(actualTranches)
    currentZone        := baseTrInt
    zoneLowPrice       := close
    percentileMaxPrice := close

// 每根 bar 的逻辑
if not na(p)
    // 更新全局最高价，作为网格上沿
    if na(percentileMaxPrice)
        percentileMaxPrice := high
    else
        percentileMaxPrice := math.max(percentileMaxPrice, high)

    // 1) 如果基础分位区间发生改变，立即把仓位调整到新的基础份数，并重置该区间的上下沿
    bool zoneChanged = baseTrInt != currentZone
    if inRange and zoneChanged
        int prevZone = currentZone
        currentZone  := baseTrInt
        zoneLowPrice := close
        if baseTrInt > prevZone
            actualTranches := baseTrInt
            f_rebalance_to_tranches(actualTranches)

    // 2) 记录当前分位区间的下沿价格：进入区间时取当前价，之后保持不变
    if na(zoneLowPrice)
        zoneLowPrice := close

    // 3) 根据价格在 [分位区间下沿, 全局最高价] 内所处的位置，动态分配“总仓位”做网格
    float upperBound = na(percentileMaxPrice) ? close : percentileMaxPrice
    upperBound := math.max(upperBound, zoneLowPrice)
    float zoneRange = upperBound - zoneLowPrice
    float normalizedPos = zoneRange > 0 ? (close - zoneLowPrice) / zoneRange : 0.0
    normalizedPos := math.max(0.0, math.min(1.0, normalizedPos))

    float stepRatio = gridCount > 0 ? 1.0 / gridCount : 1.0
    float snappedPos = stepRatio > 0 ? math.round(normalizedPos / stepRatio) * stepRatio : normalizedPos
    snappedPos := math.max(0.0, math.min(1.0, snappedPos))

    float allocation = 1.0 - snappedPos
    int targetTr = math.round(currentZone * allocation)

    targetTr := math.max(0, math.min(numTranches, targetTr))
    if inRange and targetTr != actualTranches
        actualTranches := targetTr
        f_rebalance_to_tranches(actualTranches)

// 在状态栏显示当前网格上下沿
plot(not useCustomRange or inRange ? zoneLowPrice : na, title = "网格下沿",         display = display.status_line, color = color.new(color.green, 0))
plot(not useCustomRange or inRange ? percentileMaxPrice : na, title = "网格上沿", display = display.status_line, color = color.new(color.red, 0))

// 在最后一根K上标注当前信息
float targetQty  = actualTranches * trancheQty
float targetUsd  = not na(close) ? targetQty * close : na
float actualQty  = strategy.position_size
float actualUsd  = not na(close) ? actualQty * close : na
float currentPosPrice = strategy.position_avg_price
if barstate.islast and not na(p) and not na(targetUsd) and not na(actualUsd) and not na(actualQty) and not na(currentPosPrice) and inRange
    label.new(bar_index, high, text = str.format("分位数: {0,number,#.0}%\n目标金额: ${1,number,#,##0}\n当前持仓: {2,number,#.####}@${3,number,#,##0.##}\n持仓金额: ${4,number,#,##0}", p, targetUsd, actualQty, currentPosPrice, actualUsd), style = label.style_label_down, textcolor = color.white, color = color.new(color.blue, 60))
