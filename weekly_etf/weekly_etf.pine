//@version=6
indicator("ETF轮动 (周动能)", overlay=false, max_lines_count=500, max_labels_count=500)

// === Inputs ===
symbol1 = input.symbol("SSE:518880", "Symbol 1", group="Universe")
name1   = input.string("黄金ETF", "Label 1", group="Universe")
symbol2 = input.symbol("SSE:513100", "Symbol 2", group="Universe")
name2   = input.string("纳指ETF", "Label 2", group="Universe")
symbol3 = input.symbol("SZSE:159915", "Symbol 3", group="Universe")
name3   = input.string("创业板ETF", "Label 3", group="Universe")
symbol4 = input.symbol("SSE:513520", "Symbol 4", group="Universe")
name4   = input.string("日经ETF", "Label 4", group="Universe")
rotationCount = input.int(3, "参与轮动资产数量", minval=1, maxval=4, group="Universe", tooltip="从上面填写的资产中取前N个参与轮动")
pricePrecision  = input.int(3, "价格精确小数位", minval=0, maxval=6, group="Universe")
var bool[] riskOffExclude = array.new_bool()   // 基准跌破均线时需要移除的品种

// === Market filter (基准均线) ===
useMarketFilter = input.bool(false, "启用基准均线过滤", group="Market Filter", tooltip="基准指数跌破指定SMA时，可将部分品种从轮动列表中移除")
marketFrictionPct = input.float(0.0, "均线防摩擦系数(%)", minval=0.0, maxval=20.0, step=1, group="Market Filter", tooltip="收盘需高/低于均线一定比例才算上穿/下穿，降低震荡噪声")
forceExitOnFilter = input.bool(true, "风险过滤直接清仓", group="Market Filter", tooltip="开启后，基准跌破SMA且当前持有被标记的风险品种时，立即按日线价格平仓；价格遵循换仓时点设置（收盘 / 次日开盘）")
forceExitMode = input.string("次日开盘", "强平成交时点", options=["当日收盘", "次日开盘"], group="Market Filter", tooltip="强平触发时使用的成交价：固定当日收盘或次日开盘")
marketFilterSymbol = input.symbol("SP:SPX", "基准符号", group="Market Filter", tooltip="默认使用SPX，可自定义为其它指数或资产")
marketFilterLen = input.int(225, "基准SMA长度 (天)", minval=1, group="Market Filter", tooltip="默认225日SMA")
// 选择在风险关闭时需要移除的品种
exclude1OnDown = input.bool(false, "基准跌破均线时停用Symbol1", group="Market Filter")   // Symbol 1（黄金）
exclude2OnDown = input.bool(true,  "基准跌破均线时停用Symbol2", group="Market Filter")   // Symbol 2（纳指ETF）
exclude3OnDown = input.bool(true,  "基准跌破均线时停用Symbol3", group="Market Filter")   // Symbol 3（创业板ETF）
exclude4OnDown = input.bool(true,  "基准跌破均线时停用Symbol4", group="Market Filter")   // Symbol 4（日经ETF）

lookbackWeeks = input.int(4, "动量回顾(周)", minval=1, group="Logic")
weekAnchor = input.string("周四", "周结束日 (Week Anchor)", options=["周一", "周二", "周三", "周四", "周五"], group="Logic", tooltip="选择一周的哪一天作为周结束日,动量将从上周的这一天计算到本周的这一天")
rebalanceMode = input.string("收盘", "换仓时点", options=["收盘", "开盘"], group="Logic", tooltip="选择在最后交易日收盘还是下一个交易日开盘进行换仓")
useCloseRebalance = rebalanceMode == "收盘"
minHoldWeeks = input.int(1, "最少持有周数", minval=1, group="Logic", tooltip="持仓至少保留N周后才允许换仓，1表示每周可换")
initialCapital = input.float(1, "初始净值", minval=0, group="Logic")
preserveEmptyWeeks = input.bool(true, "保留无价格自然周", group="Logic", tooltip="开启后即使整周无本地交易数据也会补齐锚点周（用于保留完整自然周的动量窗口）；关闭则忽略无价格周")
catchupWorkdayThreshold = input.int(4, "补换仓最小工作日间隔", minval=0, maxval=10, group="Logic", tooltip="节前最后一次换仓到补价日之间的工作日数大于该阈值才提前补换仓；否则顺延到节后重新评估")
backtestStart = input.time(timestamp("2014-12-25T00:00:00"), "Backtest Start", confirm=true, group="Logic", tooltip="Only evaluate trades on or after this date.")
backtestEnd = input.time(timestamp("2099-12-31T23:59:59"), "Backtest End", confirm=true, group="Logic", tooltip="Only evaluate trades on or before this date.")
bool inRange = time >= backtestStart and time <= backtestEnd

// Week Anchor 辅助函数
getWeekAnchorDay() =>
    weekAnchor == "周一" ? dayofweek.monday :
     weekAnchor == "周二" ? dayofweek.tuesday :
     weekAnchor == "周三" ? dayofweek.wednesday :
     weekAnchor == "周四" ? dayofweek.thursday :
     dayofweek.friday

weekAnchorDay = getWeekAnchorDay()
// Display options
showForceExitLabel = input.bool(true, "显示强平标注", group="Display")
showMaxDdLabel   = input.bool(true, "显示最大回撤标注", group="Display")
// Debug options
enableDdDebug = input.bool(false, "启用回撤调试日志", group="Debug")
enableEquityDebug = input.bool(false, "启用净值调试日志", group="Debug")
enableFloatingEquityDebug = input.bool(false, "启用浮动净值调试日志", group="Debug")
enablePositionLog = input.bool(false, "启用仓位变动日志", group="Debug")
enableMomentumLog = input.bool(false, "启用动量计算日志", group="Debug")
enableFilterLog = input.bool(false, "启用基准过滤日志", group="Debug")
enableAnchorRecordLog = input.bool(false, "启用Anchor周记录日志", group="Debug")
enableAnchorStateLog = input.bool(false, "启用Anchor数组快照日志", group="Debug", tooltip="在预热/换仓触发点输出anchorDate0..4与anchorPrice0..4，用于排查lookback错位")

formatDate(int ts) =>
    if na(ts)
        "N/A"
    else
        yearStr = str.tostring(year(ts))
        monthVal = month(ts)
        dayVal = dayofmonth(ts)
        monthStr = monthVal < 10 ? "0" + str.tostring(monthVal) : str.tostring(monthVal)
        dayStr = dayVal < 10 ? "0" + str.tostring(dayVal) : str.tostring(dayVal)
        str.format("{0}-{1}-{2}", yearStr, monthStr, dayStr)

// 基准指数日线SMA（用于风险过滤）
marketClose = request.security(marketFilterSymbol, "D", close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
// 用日线bar的起始日期避免因收盘时间跨时区导致日期+1
marketDate = request.security(marketFilterSymbol, "D", time, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
marketSma = request.security(marketFilterSymbol, "D", ta.sma(close, marketFilterLen), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
friction = marketFrictionPct * 0.01
smaUp = marketSma * (1 + friction)
smaDown = marketSma * (1 - friction)
marketAboveSma = marketClose >= smaUp
marketBelowSma = marketClose <= smaDown
marketCrossUp = ta.crossover(marketClose, smaUp)
marketCrossDown = ta.crossunder(marketClose, smaDown)
// 风险过滤状态：下穿时进入风险关闭(true)，上穿时恢复正常(false)
var bool marketRiskOff = false
if useMarketFilter and inRange and barstate.isconfirmed and (marketCrossUp or marketCrossDown)
    dirTxt = marketCrossUp ? "上穿" : "下穿"
    crossDateTxt = formatDate(marketDate)
    if marketCrossDown
        marketRiskOff := true
    else if marketCrossUp
        marketRiskOff := false
    if enableFilterLog
        log.warning(str.format("基准 {0} {1} SMA{2}±{3,number,#.##}% 交易日 {4} 收盘 {5} 上沿 {6} 下沿 {7}", marketFilterSymbol, dirTxt, marketFilterLen, marketFrictionPct, crossDateTxt, str.tostring(marketClose, format.mintick), str.tostring(smaUp, format.mintick), str.tostring(smaDown, format.mintick)))

// === Build symbol lists ===
var string[] tickers = array.new_string()
var string[] labels  = array.new_string()
if barstate.isfirst
    array.clear(riskOffExclude)
    if str.length(symbol1) > 0
        array.push(tickers, symbol1)
        array.push(labels,  name1)
        array.push(riskOffExclude, exclude1OnDown)
    if str.length(symbol2) > 0
        array.push(tickers, symbol2)
        array.push(labels,  name2)
        array.push(riskOffExclude, exclude2OnDown)
    if str.length(symbol3) > 0
        array.push(tickers, symbol3)
        array.push(labels,  name3)
        array.push(riskOffExclude, exclude3OnDown)
    if str.length(symbol4) > 0
        array.push(tickers, symbol4)
        array.push(labels,  name4)
        array.push(riskOffExclude, exclude4OnDown)
    // Remove accidental empties
    idx = array.size(tickers) - 1
    while idx >= 0
        sym = array.get(tickers, idx)
        if str.length(sym) == 0
            array.remove(tickers, idx)
            array.remove(labels, idx)
            array.remove(riskOffExclude, idx)
        idx -= 1
    // Trim to rotationCount (take first N assets)
    while array.size(tickers) > rotationCount
        array.pop(tickers)
        array.pop(labels)
        array.pop(riskOffExclude)

assetCount = array.size(tickers)
if assetCount == 0
    runtime.error("请至少填写一个可交易品种")

// Arrays reused each bar to store metrics
var float[] momentum4w = array.new_float()
var float[] weeklyRet  = array.new_float()
var float[] weeklyClose = array.new_float()
var float[] lookbackClose = array.new_float()
var int[] displayOrder = array.new_int()
// Per-symbol performance stats
var float[] symCumReturn = array.new_float()   // 累计收益倍数（仅统计持仓周）
var float[] symProfitSum = array.new_float()   // 周度盈利之和（小数，例如0.05=+5%）
var float[] symLossSum   = array.new_float()   // 周度亏损之和（负数）
var int[] symWinCount    = array.new_int()     // 盈利周次数
var int[] symTradeCount  = array.new_int()     // 持仓周次数
// Week anchor历史价格追踪 - 使用多个数组分别存储不同周的价格
var float[] lastBarClose = array.new_float()  // 上一个bar的收盘价(用于新周记录)
var int[] lastBarTime = array.new_int()       // 上一个bar的时间(用于新周记录)
var float[] anchorPrice0 = array.new_float()  // 当前周anchor日价格
var float[] anchorPrice1 = array.new_float()  // 1周前anchor日价格
var float[] anchorPrice2 = array.new_float()  // 2周前
var float[] anchorPrice3 = array.new_float()  // 3周前
var float[] anchorPrice4 = array.new_float()  // 4周前
var float[] anchorPrice5 = array.new_float()  // 5周前
var float[] anchorPrice6 = array.new_float()  // 6周前
var float[] anchorPrice7 = array.new_float()  // 7周前
var float[] anchorPrice8 = array.new_float()  // 8周前
var float[] anchorPrice9 = array.new_float()  // 9周前
var float[] anchorPrice10 = array.new_float() // 10周前(支持最多10周lookback)
// Week anchor历史日期追踪 - 使用多个数组分别存储不同周的anchor日期
var int[] anchorDate0 = array.new_int()   // 当前周anchor日的实际日期
var int[] anchorDate1 = array.new_int()   // 1周前
var int[] anchorDate2 = array.new_int()   // 2周前
var int[] anchorDate3 = array.new_int()   // 3周前
var int[] anchorDate4 = array.new_int()   // 4周前
var int[] anchorDate5 = array.new_int()   // 5周前
var int[] anchorDate6 = array.new_int()   // 6周前
var int[] anchorDate7 = array.new_int()   // 7周前
var int[] anchorDate8 = array.new_int()   // 8周前
var int[] anchorDate9 = array.new_int()   // 9周前
var int[] anchorDate10 = array.new_int()  // 10周前

// Shift anchor history arrays by 1 "anchor week" slot.
shiftAnchorHistory(int i, float recordClose, int recordTime) =>
    // Prices
    array.set(anchorPrice10, i, array.get(anchorPrice9, i))
    array.set(anchorPrice9, i, array.get(anchorPrice8, i))
    array.set(anchorPrice8, i, array.get(anchorPrice7, i))
    array.set(anchorPrice7, i, array.get(anchorPrice6, i))
    array.set(anchorPrice6, i, array.get(anchorPrice5, i))
    array.set(anchorPrice5, i, array.get(anchorPrice4, i))
    array.set(anchorPrice4, i, array.get(anchorPrice3, i))
    array.set(anchorPrice3, i, array.get(anchorPrice2, i))
    array.set(anchorPrice2, i, array.get(anchorPrice1, i))
    array.set(anchorPrice1, i, array.get(anchorPrice0, i))
    array.set(anchorPrice0, i, recordClose)
    // Dates
    array.set(anchorDate10, i, array.get(anchorDate9, i))
    array.set(anchorDate9, i, array.get(anchorDate8, i))
    array.set(anchorDate8, i, array.get(anchorDate7, i))
    array.set(anchorDate7, i, array.get(anchorDate6, i))
    array.set(anchorDate6, i, array.get(anchorDate5, i))
    array.set(anchorDate5, i, array.get(anchorDate4, i))
    array.set(anchorDate4, i, array.get(anchorDate3, i))
    array.set(anchorDate3, i, array.get(anchorDate2, i))
    array.set(anchorDate2, i, array.get(anchorDate1, i))
    array.set(anchorDate1, i, array.get(anchorDate0, i))
    array.set(anchorDate0, i, recordTime)

// 计算两个日期之间的工作日天数（仅统计周一至周五）
countWorkdaysBetween(int startTs, int endTs) =>
    if na(startTs) or na(endTs) or endTs <= startTs
        0
    else
        int totalDays = int((endTs - startTs) / 86400000)
        int workdays = 0
        for offset = 1 to totalDays
            int currTs = startTs + offset * 86400000
            int currDow = dayofweek(currTs)
            if currDow >= dayofweek.monday and currDow <= dayofweek.friday
                workdays += 1
        workdays

if barstate.isfirst
    array.clear(momentum4w)
    array.clear(weeklyRet)
    array.clear(weeklyClose)
    array.clear(lookbackClose)
    array.clear(displayOrder)
    array.clear(symCumReturn)
    array.clear(symProfitSum)
    array.clear(symLossSum)
    array.clear(symWinCount)
    array.clear(symTradeCount)
    array.clear(lastBarClose)
    array.clear(lastBarTime)
    array.clear(anchorPrice0)
    array.clear(anchorPrice1)
    array.clear(anchorPrice2)
    array.clear(anchorPrice3)
    array.clear(anchorPrice4)
    array.clear(anchorPrice5)
    array.clear(anchorPrice6)
    array.clear(anchorPrice7)
    array.clear(anchorPrice8)
    array.clear(anchorPrice9)
    array.clear(anchorPrice10)
    array.clear(anchorDate0)
    array.clear(anchorDate1)
    array.clear(anchorDate2)
    array.clear(anchorDate3)
    array.clear(anchorDate4)
    array.clear(anchorDate5)
    array.clear(anchorDate6)
    array.clear(anchorDate7)
    array.clear(anchorDate8)
    array.clear(anchorDate9)
    array.clear(anchorDate10)
    for i = 0 to assetCount - 1
        array.push(momentum4w, na)
        array.push(weeklyRet,  na)
        array.push(weeklyClose, na)
        array.push(lookbackClose, na)
        array.push(displayOrder, i)
        array.push(symCumReturn, 1.0)
        array.push(symProfitSum, 0.0)
        array.push(symLossSum,   0.0)
        array.push(symWinCount,  0)
        array.push(symTradeCount, 0)
        // 初始化anchor价格数组
        array.push(lastBarClose, na)
        array.push(lastBarTime, na)
        array.push(anchorPrice0, na)
        array.push(anchorPrice1, na)
        array.push(anchorPrice2, na)
        array.push(anchorPrice3, na)
        array.push(anchorPrice4, na)
        array.push(anchorPrice5, na)
        array.push(anchorPrice6, na)
        array.push(anchorPrice7, na)
        array.push(anchorPrice8, na)
        array.push(anchorPrice9, na)
        array.push(anchorPrice10, na)
        // 初始化anchor日期数组
        array.push(anchorDate0, na)
        array.push(anchorDate1, na)
        array.push(anchorDate2, na)
        array.push(anchorDate3, na)
        array.push(anchorDate4, na)
        array.push(anchorDate5, na)
        array.push(anchorDate6, na)
        array.push(anchorDate7, na)
        array.push(anchorDate8, na)
        array.push(anchorDate9, na)
        array.push(anchorDate10, na)
        // riskOffExclude will be filled earlier when tickers are built

color0  = color.new(color.orange, 50)
color1  = color.new(color.blue, 50)
color2  = color.new(color.red, 50)
color3  = color.new(color.purple, 50)
getColor(int idx) =>
    idx == 0 ? color0 : idx == 1 ? color1 : idx == 2 ? color2 : idx == 3 ? color3 : na

priceScale() => math.pow(10.0, pricePrecision)
roundPrice(float v) =>
    na(v) ? na : math.round(v * priceScale()) / priceScale()
fmtPrice(float v) =>
    na(v) ? "N/A" : str.tostring(v)

// 当前品种是否在风险过滤下被移除
isSymbolEligible(int idx) =>
    if not useMarketFilter
        true
    else if not marketRiskOff
        true
    else if idx >= array.size(riskOffExclude)
        true
    else
        not array.get(riskOffExclude, idx)

rankMomentum(int idx) =>
    val = array.get(momentum4w, idx)
    isSymbolEligible(idx) ? val : na

sanitizedMomentum(float val) => na(val) ? -1e10 : val

sortTableRowsByMomentum() =>
    rows = array.size(displayOrder)
    if rows >= 2
        for i = 0 to rows - 2
            bestPos = i
            bestIdx = array.get(displayOrder, bestPos)
            bestVal = sanitizedMomentum(rankMomentum(bestIdx))
            for j = i + 1 to rows - 1
                currIdx = array.get(displayOrder, j)
                currVal = sanitizedMomentum(rankMomentum(currIdx))
                if currVal > bestVal
                    bestPos := j
                    bestIdx := currIdx
                    bestVal := currVal
            if bestPos != i
                tmp = array.get(displayOrder, i)
                array.set(displayOrder, i, array.get(displayOrder, bestPos))
                array.set(displayOrder, bestPos, tmp)

// === 锚点周（Anchor Week）的定义与边界检测 ===
//
// 核心概念：按"锚点周"分组，类似 Python 的 W-THU（以周四为结束的周）
//
// 锚点周的"周收盘"：该锚点周内最后一个交易日的 close
// - 如果锚点日（如周四）是交易日，则用周四的 close
// - 如果锚点日是节假日，则用锚点日前最近的交易日 close
//
// 边界检测逻辑：
// 在锚点日当天记录，如果锚点日是节假日则在之后的第一个交易日记录前一天的数据

currentDayOfWeek = dayofweek(time)
prevDayOfWeek = dayofweek(time[1])

// 判断当前bar是否是anchor日
isAnchorDay = currentDayOfWeek == weekAnchorDay

// shouldRecordAfterMissedAnchor：锚点日是节假日，在之后的第一个交易日记录
// 条件：今天 > 锚点日 且 前一天 < 锚点日
bool shouldRecordAfterMissedAnchor = (currentDayOfWeek > weekAnchorDay and prevDayOfWeek < weekAnchorDay)

// === 计算被跳过的锚点周数量 ===
// 功能：计算从time[1]到time之间被跳过的锚点日数量（若 currDay 就是锚点日，则不包含当前锚点日）
// 
// 例如：
// - time[1]=2-10(周三), time=2-18(周四), weekAnchorDay=5(周四)
//   锚点日有 2-11 与 2-18，但因为当前bar本身是锚点日，所以返回1（仅补 2-11）
countSkippedAnchors(prevTime, currTime, prevDay, currDay, anchorDay) =>
    count = 0

    // 计算从prevDay到第一个锚点日的天数
    daysToFirstAnchor = 0
    if prevDay >= anchorDay
        // 前一交易日>=锚点日，第一个锚点日在下周
        daysToFirstAnchor := (7 - prevDay) + anchorDay
    else
        // 前一交易日<锚点日，第一个锚点日在本周
        daysToFirstAnchor := anchorDay - prevDay

    // 第一个锚点日的时间戳
    firstAnchorTime = prevTime + daysToFirstAnchor * 86400000

    // 如果当前时间还没到第一个锚点日，返回0
    if currTime < firstAnchorTime
        count := 0
    else
        // 至少跨越了1个锚点日
        count := 1

        // 计算还有几个锚点日
        // 从第一个锚点日到当前时间的天数
        daysAfterFirstAnchor = int((currTime - firstAnchorTime) / 86400000)

        // 每7天就多一个锚点周
        additionalWeeks = int(daysAfterFirstAnchor / 7)
        count := count + additionalWeeks

    // 如果当前bar本身是锚点日，则当前锚点不算“被跳过”，需排除
    if currDay == anchorDay and count > 0
        count := count - 1

    count

// 计算需要补的锚点周数量（不包含当前这次锚点日）
// - 普通周四：skippedAnchorCount=0
// - 周四休市，周五补记：skippedAnchorCount=1（补周四）
// - 周四休市，直到下一个周四才恢复：在当周四 bar 上 skippedAnchorCount=1（先补上一个周四，再按本周四走正常）
int skippedAnchorCount = na(time[1]) ? 0 : countSkippedAnchors(time[1], time, prevDayOfWeek, currentDayOfWeek, weekAnchorDay)

// === 锚点周历史记录的数据来源规则 ===
// - 正常锚点日（isAnchorDay=true）：动量用当日 close，锚点历史记录用 close/time
// - 锚点日休市（shouldRecordAfterMissedAnchor=true）：在之后的第一个交易日，用 close[1]/time[1] 作为该锚点周收盘
// - 若 skippedAnchorCount > 0：先按 skippedAnchorCount 次用 close[1]/time[1] 补齐被跳过的锚点周；若当日同时是锚点日，再走当周锚点日的正常流程

// === 换仓流程判断 ===
// skippedAnchorCount：本bar需要补的锚点周数量（仅针对被跳过的锚点周，不包含当前锚点日）

// 正常换仓触发条件: 收盘模式在锚点日当天，开盘模式在锚点日次日

// 开盘换仓模式需要记录前一bar是否是锚点日
var bool prevBarWasAnchorDay = false
bool isNextDayAfterAnchorDay = prevBarWasAnchorDay and not isAnchorDay
if barstate.isconfirmed
    prevBarWasAnchorDay := isAnchorDay

// 判断是否应该触发换仓
rebalanceBarNoRt = useCloseRebalance ? (isAnchorDay or barstate.islastconfirmedhistory) : (isNextDayAfterAnchorDay or barstate.islastconfirmedhistory)
rebalanceRealtime = useCloseRebalance ? (isAnchorDay and barstate.isrealtime) : (isNextDayAfterAnchorDay and barstate.isrealtime)
rebalanceConfirmed = useCloseRebalance ? (isAnchorDay and barstate.isconfirmed) : (isNextDayAfterAnchorDay and barstate.isconfirmed)

// Select best performer over lookback
int bestIdx = na
var int holdingIdx = na
var int prevHoldingIdx = na
var string prevHeldLabel = "未持仓"
var float equity = initialCapital
var string heldLabel = "未持仓"
var bool holdingChanged = false
var bool hadPositionPrev = false  // 上一次换仓前是否持仓，用于日志文案
var float rebalancePriceSeries = na
var float equityClosedSeries = initialCapital  // 以周收盘价结算后的净值（阶梯曲线）
var float equityDailySeries = initialCapital   // 以日线收盘价试算的净值（连续曲线）
var float lastSellPrice = na
var float lastBuyPrice = na
var int holdingWeeks = 0
var bool firstWeekMarkerDone = false
var table infoTable = table.new(position.top_right, 9, assetCount + 1, border_width=1)
var table ddTable = table.new(position.bottom_right, 2, 6, border_width=1)
var int prevHoldingWeeksMsg = 0
// 回撤计算相关变量
var float peakEquity = initialCapital         // 净值高点
var float maxDrawdownSeries = 0.0             // 最大回撤
var label maxDdLabel = na
var float entryPrice = na                     // 开仓价格
var float entryEquity = initialCapital        // 开仓时净值
var float prevEntryPrice = na                 // 收盘换仓时保存旧仓的开仓价格
var float prevEntryEquity = na                // 收盘换仓时保存旧仓的开仓净值
var float holdingPnlSeries = na               // 持仓盈亏百分比
var float lastCurrentDdLog = na               // 用于debug日志去重
// Stats for Sharpe & annualized return
var float sumWeeklyRet = 0.0
var float sumWeeklyRetSq = 0.0
var int weeksCount = 0
// 换仓事件标记（跨块使用，先声明避免首周未声明的错误）
bool switching = false
bool entering = false
bool exitingOnly = false
bool switchEvent = false
// 强制平仓状态（风险过滤触发后次日开盘平仓）
var bool forceExitPending = false
var int forceExitPendingIdx = na
var int forceExitPendingDay = na
var float forceExitPendingBasis = na
var string forceExitPendingNote = ""

var color weekRetColor = color.orange
var float currentDrawdown = 0.0
var float annReturn = 0.0
var float sharpeAnnual = 0.0

var label lastSwitch = na
// 实时/历史提示开仓/换仓
previewIdx = bestIdx
bool previewSwitch = rebalanceRealtime and not na(previewIdx) and (na(holdingIdx) or previewIdx != holdingIdx)
bool previewContinue = rebalanceRealtime and not na(previewIdx) and not na(holdingIdx) and previewIdx == holdingIdx
bool showSwitchRealtime = previewSwitch or previewContinue
bool showSwitchConfirmed = rebalanceConfirmed
bool skipSwitchMsg = false

newDay = ta.change(time("D")) != 0

// 每个bar都更新lastBarClose和lastBarTime，用于下次锚点周记录
// 放在历史记录之前，这样当 shouldRecordAnchorWeek 时可以使用前一bar的数据
for i = 0 to assetCount - 1
    string sym = array.get(tickers, i)
    float currPrice = request.security(sym, "D", close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
    array.set(lastBarClose, i, currPrice)
    array.set(lastBarTime, i, time)

int referencePrevAnchorDate = assetCount > 0 ? array.get(anchorDate0, 0) : na
bool hasNewTradingSincePrevAnchor = preserveEmptyWeeks ? true : (na(referencePrevAnchorDate) or na(time[1]) ? true : time[1] > referencePrevAnchorDate)

// === Warm-up (预热): 在回测起始日前也要记录锚点周历史 ===
// 目的：即使 backtestStart 是锚点日，也能在 backtestStart 当天拿到 lookbackWeeks 所需的历史 anchor 价格/日期，从而允许开仓。
// 注意：这里只更新 anchorPrice*/anchorDate*；不做动量排名、换仓、净值等任何交易逻辑。
bool inWarmup = time < backtestStart
if inWarmup and barstate.isconfirmed and (skippedAnchorCount > 0 or isAnchorDay or shouldRecordAfterMissedAnchor)
    // 先补齐被跳过的锚点周（近似处理：统一使用 close[1]/time[1]）
    int warmupCatchupCount = preserveEmptyWeeks ? skippedAnchorCount : ((skippedAnchorCount > 0 and hasNewTradingSincePrevAnchor) ? 1 : 0)
    if warmupCatchupCount > 0
        for weekIdx = 0 to warmupCatchupCount - 1
            for i = 0 to assetCount - 1
                string sym = array.get(tickers, i)
                float recordClose = request.security(sym, "D", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                int recordTime = time[1]
                shiftAnchorHistory(i, recordClose, recordTime)
    // 再记录当前锚点日（用当日 close/time）
    if isAnchorDay
        for i = 0 to assetCount - 1
            string sym = array.get(tickers, i)
            float recordClose = request.security(sym, "D", close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
            int recordTime = time
            shiftAnchorHistory(i, recordClose, recordTime)
    // 兜底：极端情况下 shouldRecordAfterMissedAnchor=true 但 skippedAnchorCount=0
    if shouldRecordAfterMissedAnchor and skippedAnchorCount == 0 and not isAnchorDay
        for i = 0 to assetCount - 1
            string sym = array.get(tickers, i)
            float recordClose = request.security(sym, "D", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
            int recordTime = time[1]
            shiftAnchorHistory(i, recordClose, recordTime)
    if enableAnchorRecordLog
        string currTxt = isAnchorDay ? "是" : "否"
        log.warning(str.format("预热记录锚点周历史: skipped={0} 记录当前锚点={1}", skippedAnchorCount, currTxt))
    if enableAnchorStateLog and assetCount > 0
        int di = 0
        string snap = str.format(
             "AnchorSnapshot[Warmup] {0} anchor={1} skipped={2} D0={3} D1={4} D2={5} D3={6} D4={7} | P0={8} P1={9} P2={10} P3={11} P4={12}",
             formatDate(time),
             isAnchorDay ? "Y" : "N",
             skippedAnchorCount,
             formatDate(array.get(anchorDate0, di)),
             formatDate(array.get(anchorDate1, di)),
             formatDate(array.get(anchorDate2, di)),
             formatDate(array.get(anchorDate3, di)),
             formatDate(array.get(anchorDate4, di)),
             fmtPrice(array.get(anchorPrice0, di)),
             fmtPrice(array.get(anchorPrice1, di)),
             fmtPrice(array.get(anchorPrice2, di)),
             fmtPrice(array.get(anchorPrice3, di)),
             fmtPrice(array.get(anchorPrice4, di))
        )
        log.warning(snap)

// === 补换仓循环: 处理错过的锚点周 ===
// 当 skippedAnchorCount > 0 时，表示本bar需要补 skippedAnchorCount 个锚点周（不包含当前锚点日）。
// 补换仓每轮流程：
// 1) 基于 close[1]/time[1] 计算动量
// 2) 按 close[1] 成交执行补换仓
// 3) shiftAnchorHistory(close[1], time[1]) 将补录周写入 anchorPrice*/anchorDate*
bool needsCatchupRebalance = skippedAnchorCount >= 1

int catchupWorkdayGap = not na(referencePrevAnchorDate) and not na(time[1]) ? countWorkdaysBetween(referencePrevAnchorDate, time[1]) : na
bool allowCatchupRebalance = na(catchupWorkdayGap) ? true : catchupWorkdayGap > catchupWorkdayThreshold

if inRange
    if needsCatchupRebalance and barstate.isconfirmed
        // 循环处理需要补的锚点周
        int catchupRecordCount = 0
        if skippedAnchorCount > 0
            catchupRecordCount := preserveEmptyWeeks ? skippedAnchorCount : (hasNewTradingSincePrevAnchor ? 1 : 0)
        if catchupRecordCount > 0
            if enablePositionLog
                string gapTxt = na(catchupWorkdayGap) ? "N/A" : str.tostring(catchupWorkdayGap)
                string decisionTxt = allowCatchupRebalance ? "执行补换仓" : "跳过补换仓"
                log.warning(str.format("补换仓判定: workdayGap={0} 阈值={1} -> {2}", gapTxt, catchupWorkdayThreshold, decisionTxt))
            for weekIdx = 0 to catchupRecordCount - 1
                // 仅当工作日间隔超过阈值且是第一个错过周时才补换仓，其余周只记录Anchor
                bool performCatchupTrade = allowCatchupRebalance and weekIdx == 0
                bool hasPriceData = performCatchupTrade
                if hasPriceData
                    // 计算该周动量(补动量) - 先计算后回写锚点历史，保持与正常换仓一致
                    for i = 0 to assetCount - 1
                        string sym = array.get(tickers, i)

                        // 补动量: 使用前一交易日(锚点周收盘日)的数据
                        float currAnchorClose = request.security(sym, "D", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                        int currAnchorDate = time[1]

                        // 上一个anchor周价格(1周前)
                        float prevAnchorClose1 = array.get(anchorPrice0, i)

                        // lookbackWeeks前的anchor日价格
                        float lookbackAnchorClose = lookbackWeeks == 1 ? array.get(anchorPrice0, i) : lookbackWeeks == 2 ? array.get(anchorPrice1, i) : lookbackWeeks == 3 ? array.get(anchorPrice2, i) : lookbackWeeks == 4 ? array.get(anchorPrice3, i) : lookbackWeeks == 5 ? array.get(anchorPrice4, i) : lookbackWeeks == 6 ? array.get(anchorPrice5, i) : lookbackWeeks == 7 ? array.get(anchorPrice6, i) : lookbackWeeks == 8 ? array.get(anchorPrice7, i) : lookbackWeeks == 9 ? array.get(anchorPrice8, i) : array.get(anchorPrice9, i)

                        // 获取对应的日期
                        int lookbackAnchorDate = lookbackWeeks == 1 ? array.get(anchorDate0, i) : lookbackWeeks == 2 ? array.get(anchorDate1, i) : lookbackWeeks == 3 ? array.get(anchorDate2, i) : lookbackWeeks == 4 ? array.get(anchorDate3, i) : lookbackWeeks == 5 ? array.get(anchorDate4, i) : lookbackWeeks == 6 ? array.get(anchorDate5, i) : lookbackWeeks == 7 ? array.get(anchorDate6, i) : lookbackWeeks == 8 ? array.get(anchorDate7, i) : lookbackWeeks == 9 ? array.get(anchorDate8, i) : array.get(anchorDate9, i)

                        // 计算涨跌幅
                        float weeklyPct = not na(currAnchorClose) and not na(prevAnchorClose1) and prevAnchorClose1 > 0 ? currAnchorClose / prevAnchorClose1 - 1 : na
                        float momentum4wPct = not na(currAnchorClose) and not na(lookbackAnchorClose) and lookbackAnchorClose > 0 ? currAnchorClose / lookbackAnchorClose - 1 : na

                        if na(currAnchorClose) or na(weeklyPct)
                            continue  // skip symbols with insufficient history

                        string lbl = array.get(labels, i)
                        string currDateStr = formatDate(currAnchorDate)
                        string lookbackDateStr = formatDate(lookbackAnchorDate)
                        if enableMomentumLog
                            log.info(str.format("[补动量 weekIdx={0}] Symbol: {1} ({2}) Anchor日[{3}]: {4} 本周涨幅: {5,number,#.##}% {6}周前Anchor日[{7}]: {8} {6}周涨幅: {9,number,#.##}%",
                                weekIdx, sym, lbl, currDateStr, currAnchorClose, weeklyPct * 100, lookbackWeeks, lookbackDateStr, lookbackAnchorClose, momentum4wPct * 100))

                        array.set(weeklyClose, i, currAnchorClose)
                        array.set(weeklyRet,  i, weeklyPct)
                        array.set(momentum4w, i, momentum4wPct)
                        array.set(lookbackClose, i, lookbackAnchorClose)

                    // 选择最佳标的
                    float bestMomentum = -10e10
                    int bestIdx = na
                    for i = 0 to assetCount - 1
                        float mom = rankMomentum(i)
                        if not na(mom) and mom > bestMomentum
                            bestMomentum := mom
                            bestIdx := i

                    // 执行补换仓
                    if not na(bestIdx)
                        int prevHoldingIdxSnap = holdingIdx
                        bool hadPositionPrev = not na(prevHoldingIdxSnap)
                        string prevHeldLabelSnap = hadPositionPrev ? array.get(labels, prevHoldingIdxSnap) : "未持仓"
                        int prevHoldingWeeksSnap = holdingWeeks

                        // Determine next holding
                        int weeksHeld = hadPositionPrev ? holdingWeeks + 1 : 0
                        int nextIdx = bestIdx
                        bool holdLockActive = hadPositionPrev and not na(nextIdx) and weeksHeld < minHoldWeeks and isSymbolEligible(prevHoldingIdxSnap)
                        if holdLockActive
                            nextIdx := prevHoldingIdxSnap

                        bool hasCandidate = not na(nextIdx)
                        bool switching = hadPositionPrev and hasCandidate and nextIdx != prevHoldingIdxSnap
                        bool exitingOnly = hadPositionPrev and not hasCandidate
                        bool entering = hasCandidate and (not hadPositionPrev or switching)
                        bool switchEvent = switching or entering or exitingOnly

                        // 递增持仓周计数
                        if hadPositionPrev and not switching and not exitingOnly
                            holdingWeeks := weeksHeld

                        // 补换仓日志相关变量
                        string sellTxt = "—"
                        string buyTxt = "—"
                        float sellPrice = na
                        float buyPrice = na

                        // Realize when exiting (switch or exit)
                        if switching or exitingOnly
                            int exitIdx = prevHoldingIdxSnap
                            string exitSym = array.get(tickers, exitIdx)
                            string exitLabel = array.get(labels, exitIdx)
                            // 补换仓: 使用前一交易日(锚点周收盘日)的收盘价
                            float exitPrice = roundPrice(request.security(exitSym, "D", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
                            float basisPrice = entryPrice
                            float realized = not na(exitPrice) and not na(basisPrice) and basisPrice > 0 ? exitPrice / basisPrice - 1 : na
                            if not na(realized)
                                equity := equity * (1 + realized)
                                // stats per trade
                                float prevMul = array.get(symCumReturn, exitIdx)
                                array.set(symCumReturn, exitIdx, nz(prevMul, 1.0) * (1 + realized))
                                int prevTrades = array.get(symTradeCount, exitIdx)
                                array.set(symTradeCount, exitIdx, prevTrades + 1)
                                if realized > 0
                                    array.set(symWinCount, exitIdx, array.get(symWinCount, exitIdx) + 1)
                                    array.set(symProfitSum, exitIdx, array.get(symProfitSum, exitIdx) + realized)
                                else if realized < 0
                                    array.set(symLossSum, exitIdx, array.get(symLossSum, exitIdx) + realized)
                                // 累计收益统计
                                sumWeeklyRet += realized
                                sumWeeklyRetSq += realized * realized
                                weeksCount += 1

                            equityClosedSeries := equity
                            lastSellPrice := exitPrice
                            holdingWeeks := 0
                            sellPrice := exitPrice
                            sellTxt := fmtPrice(exitPrice)
                        else
                            // 持续持有
                            equityClosedSeries := equity
                            lastSellPrice := na

                        // 开仓/换仓
                        if entering
                            // 补换仓: 使用前一交易日(锚点周收盘日)的收盘价
                            float nextBuyPrice = roundPrice(request.security(array.get(tickers, nextIdx), "D", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
                            entryPrice := nextBuyPrice
                            entryEquity := equity
                            lastBuyPrice := nextBuyPrice
                            buyPrice := nextBuyPrice
                            buyTxt := fmtPrice(nextBuyPrice)
                        else if exitingOnly
                            entryPrice := na
                            entryEquity := equity
                            lastBuyPrice := na

                        holdingIdx := hasCandidate ? nextIdx : na
                        heldLabel := not na(holdingIdx) ? array.get(labels, holdingIdx) : "未持仓"

                        // 统一格式的补换仓日志
                        if enablePositionLog and switchEvent
                            // 计算目标锚点日期
                            int daysToTargetAnchor = weekAnchorDay - prevDayOfWeek
                            if daysToTargetAnchor <= 0
                                daysToTargetAnchor := daysToTargetAnchor + 7
                            int targetAnchorTime = time[1] + daysToTargetAnchor * 86400000
                            string targetDate = formatDate(targetAnchorTime)
                            string actualDate = formatDate(time[1])
                            string rebalanceTiming = useCloseRebalance ? "收盘" : "次日开盘"
                            string timingTxt = str.format("[补换仓 目标:{0} 实际:{1} {2}]", targetDate, actualDate, rebalanceTiming)

                            if entering and not switching and not hadPositionPrev
                                log.error(str.format("开仓{0}: {1}@{2}", timingTxt, heldLabel, buyTxt))
                            else if exitingOnly
                                log.error(str.format("平仓{0}: {1}@{2}", timingTxt, prevHeldLabelSnap, sellTxt))
                            else
                                log.error(str.format("换仓{0}: {1}@{2} -> {3}@{4}", timingTxt, prevHeldLabelSnap, sellTxt, heldLabel, buyTxt))
                else
                    if enableAnchorRecordLog
                        int catchupRecordTimeSkip = time[1]
                        int daysToFirstAnchorSkip = 0
                        if prevDayOfWeek >= weekAnchorDay
                            daysToFirstAnchorSkip := (7 - prevDayOfWeek) + weekAnchorDay
                        else
                            daysToFirstAnchorSkip := weekAnchorDay - prevDayOfWeek
                        int targetAnchorTimeSkip = time[1] + (daysToFirstAnchorSkip + weekIdx * 7) * 86400000
                        string targetAnchorDateSkip = na(targetAnchorTimeSkip) ? "N/A" : formatDate(targetAnchorTimeSkip)
                        string skipReason = allowCatchupRebalance ? "按策略仅记录Anchor历史" : str.format("工作日间隔<=阈值({0})，跳过补换仓", catchupWorkdayThreshold)
                        log.warning(str.format("补换仓周锚点: weekIdx={0} 日期={1} (仅记录close[1]; {2}) 目标Anchor日={3}", weekIdx, formatDate(catchupRecordTimeSkip), skipReason, targetAnchorDateSkip))

                // 补换仓执行完后再写入锚点历史，保持与正常换仓一致
                int catchupRecordTime = na
                for i = 0 to assetCount - 1
                    string sym = array.get(tickers, i)
                    float recordClose = request.security(sym, "D", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                    int recordTime = time[1]
                    if i == 0
                        catchupRecordTime := recordTime
                    shiftAnchorHistory(i, recordClose, recordTime)

                if enableAnchorRecordLog and hasPriceData
                    string recordNote = "使用close[1]"
                    // 计算本次补录对应的目标锚点日期（日历上的anchor日）
                    int targetAnchorTime = na
                    // 从上一根bar所在日期出发，找到第一个anchor日
                    int daysToFirstAnchor = 0
                    if prevDayOfWeek >= weekAnchorDay
                        daysToFirstAnchor := (7 - prevDayOfWeek) + weekAnchorDay
                    else
                        daysToFirstAnchor := weekAnchorDay - prevDayOfWeek
                    // 第 weekIdx 个被跳过的anchor周，对应 firstAnchor + weekIdx*7 天
                    targetAnchorTime := time[1] + (daysToFirstAnchor + weekIdx * 7) * 86400000
                    string targetAnchorDateTxt = na(targetAnchorTime) ? "N/A" : formatDate(targetAnchorTime)
                    log.warning(str.format("补换仓周锚点: weekIdx={0} 日期={1} ({2}) 目标Anchor日={3}", weekIdx, formatDate(catchupRecordTime), recordNote, targetAnchorDateTxt))
        else if enableAnchorRecordLog and skippedAnchorCount > 0 and not preserveEmptyWeeks and not hasNewTradingSincePrevAnchor
            log.warning("补换仓判定: 缺少新交易日，跳过本次锚点补录/换仓")


    if rebalanceBarNoRt
        // 动量计算（正常换仓或单周假期补换仓）
        bool isDelayedRebalance = shouldRecordAfterMissedAnchor and skippedAnchorCount == 1

        // 计算被错过的锚点日日期（用于日志）
        int missedAnchorTime = na
        if isDelayedRebalance
            int daysToAdd = weekAnchorDay - prevDayOfWeek
            if daysToAdd < 0
                daysToAdd := daysToAdd + 7
            missedAnchorTime := time[1] + daysToAdd * 86400000

        if enableAnchorStateLog and barstate.isconfirmed and assetCount > 0
            int di = 0
            string snap = str.format(
                 "AnchorSnapshot[BeforeMomentum] {0} anchor={1} delayed={2} skipped={3} prevDOW={4} currDOW={5} anchorDOW={6} lb={7} D0={8} D1={9} D2={10} D3={11} D4={12} | P0={13} P1={14} P2={15} P3={16} P4={17}",
                 formatDate(time),
                 isAnchorDay ? "Y" : "N",
                 isDelayedRebalance ? "Y" : "N",
                 skippedAnchorCount,
                 str.tostring(prevDayOfWeek),
                 str.tostring(currentDayOfWeek),
                 str.tostring(weekAnchorDay),
                 lookbackWeeks,
                 formatDate(array.get(anchorDate0, di)),
                 formatDate(array.get(anchorDate1, di)),
                 formatDate(array.get(anchorDate2, di)),
                 formatDate(array.get(anchorDate3, di)),
                 formatDate(array.get(anchorDate4, di)),
                 fmtPrice(array.get(anchorPrice0, di)),
                 fmtPrice(array.get(anchorPrice1, di)),
                 fmtPrice(array.get(anchorPrice2, di)),
                 fmtPrice(array.get(anchorPrice3, di)),
                 fmtPrice(array.get(anchorPrice4, di))
            )
            log.warning(snap)

        for i = 0 to assetCount - 1
            string sym = array.get(tickers, i)

            // 选择数据源
            float currAnchorClose = na
            int currAnchorDate = na
            if isDelayedRebalance
                // 延迟换仓：使用前一交易日数据
                currAnchorClose := request.security(sym, "D", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                currAnchorDate := time[1]
            else
                // 正常换仓：使用当前bar数据
                currAnchorClose := array.get(lastBarClose, i)
                currAnchorDate := array.get(lastBarTime, i)

            float prevAnchorClose1 = array.get(anchorPrice0, i)
            // lookbackWeeks前的anchor日价格
            float lookbackAnchorClose = lookbackWeeks == 1 ? array.get(anchorPrice0, i) : lookbackWeeks == 2 ? array.get(anchorPrice1, i) : lookbackWeeks == 3 ? array.get(anchorPrice2, i) : lookbackWeeks == 4 ? array.get(anchorPrice3, i) : lookbackWeeks == 5 ? array.get(anchorPrice4, i) : lookbackWeeks == 6 ? array.get(anchorPrice5, i) : lookbackWeeks == 7 ? array.get(anchorPrice6, i) : lookbackWeeks == 8 ? array.get(anchorPrice7, i) : lookbackWeeks == 9 ? array.get(anchorPrice8, i) : array.get(anchorPrice9, i)

            int lookbackAnchorDate = lookbackWeeks == 1 ? array.get(anchorDate0, i) : lookbackWeeks == 2 ? array.get(anchorDate1, i) : lookbackWeeks == 3 ? array.get(anchorDate2, i) : lookbackWeeks == 4 ? array.get(anchorDate3, i) : lookbackWeeks == 5 ? array.get(anchorDate4, i) : lookbackWeeks == 6 ? array.get(anchorDate5, i) : lookbackWeeks == 7 ? array.get(anchorDate6, i) : lookbackWeeks == 8 ? array.get(anchorDate7, i) : lookbackWeeks == 9 ? array.get(anchorDate8, i) : array.get(anchorDate9, i)

            // 计算涨跌幅
            float weeklyPct = not na(currAnchorClose) and not na(prevAnchorClose1) and prevAnchorClose1 > 0 ? currAnchorClose / prevAnchorClose1 - 1 : na
            float momentum4wPct = not na(currAnchorClose) and not na(lookbackAnchorClose) and lookbackAnchorClose > 0 ? currAnchorClose / lookbackAnchorClose - 1 : na

            if na(currAnchorClose) or na(weeklyPct)
                continue  // skip symbols with insufficient history
            string lbl = array.get(labels, i)
            string currDateStr = formatDate(currAnchorDate)
            string lookbackDateStr = formatDate(lookbackAnchorDate)
            if enableMomentumLog
                string rebalanceType = isDelayedRebalance ? str.format("[补动量计算 目标Anchor:{0}] ", formatDate(missedAnchorTime)) : ""
                log.info(str.format("{0}Symbol: {1} ({2}) Anchor日[{3}]: {4} 本周涨幅: {5,number,#.##}% {6}周前Anchor日[{7}]: {8} {6}周涨幅: {9,number,#.##}%",
                    rebalanceType, sym, lbl, currDateStr, currAnchorClose, weeklyPct * 100, lookbackWeeks, lookbackDateStr, lookbackAnchorClose, momentum4wPct * 100))
            array.set(weeklyClose, i, currAnchorClose)
            array.set(weeklyRet,  i, weeklyPct)
            array.set(momentum4w, i, momentum4wPct)
            array.set(lookbackClose, i, lookbackAnchorClose)

        float bestMomentum = -10e10
        for i = 0 to assetCount - 1
            float mom = rankMomentum(i)
            if not na(mom) and mom > bestMomentum
                bestMomentum := mom
                bestIdx := i


    // === 风险过滤即时平仓逻辑（基准跌破且持有被标记风险资产时） ===
    int currDayStart = int(time("D"))
    bool forceExitExecuted = false
    bool filterActive = useMarketFilter and marketBelowSma
    bool holdingRisky = not na(holdingIdx) and holdingIdx < array.size(riskOffExclude) and array.get(riskOffExclude, holdingIdx)
    bool forceExitUseClose = forceExitMode == "当日收盘"

    // 当日收盘平仓
    if forceExitOnFilter and filterActive and holdingRisky and forceExitUseClose and not forceExitPending
        string exitSym = array.get(tickers, holdingIdx)
        string exitLabel = array.get(labels, holdingIdx)
        float exitPrice = roundPrice(request.security(exitSym, "D", close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
        float basisPrice = entryPrice
        float realized = not na(exitPrice) and not na(basisPrice) and basisPrice > 0 ? exitPrice / basisPrice - 1 : na
        if not na(realized)
            equity := equity * (1 + realized)
        equityClosedSeries := equity
        lastSellPrice := exitPrice
        holdingChanged := true
        prevHeldLabel := exitLabel
        holdingIdx := na
        heldLabel := "未持仓"
        holdingWeeks := 0
        entryPrice := na
        // 强平后不再展示持仓盈亏
        holdingPnlSeries := na
        rebalancePriceSeries := exitPrice
        forceExitExecuted := true
        // 标注强平（当日收盘执行）
        if showForceExitLabel
            string exitTimeTxt = formatDate(time)
            string exitModeTxt = "收盘"
            string exitLblTxt = str.format("强平 {0}\n时间: {1} {2}\n价格: {3}", exitLabel, exitTimeTxt, exitModeTxt, fmtPrice(exitPrice))
            label.new(bar_index, equity, exitLblTxt, color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.small)
        if enablePositionLog
            log.error(str.format("风险过滤清仓: {0} @ {1}", exitLabel, fmtPrice(exitPrice)))

    // 次日开盘平仓：记录计划，等到新交易日第一根bar执行
    if forceExitOnFilter and filterActive and holdingRisky and not forceExitUseClose and not forceExitPending
        forceExitPending := true
        forceExitPendingIdx := holdingIdx
        forceExitPendingDay := currDayStart
        forceExitPendingBasis := entryPrice
        forceExitPendingNote := "（次日开盘清仓）"

    if forceExitPending and (currDayStart > forceExitPendingDay or (currDayStart == forceExitPendingDay and newDay))
        int exitSymIdx = forceExitPendingIdx
        string exitSym = array.get(tickers, exitSymIdx)
        string exitLabel = array.get(labels, exitSymIdx)
        float exitPrice = roundPrice(request.security(exitSym, "D", open, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
        float basisPrice = forceExitPendingBasis
        float realized = not na(exitPrice) and not na(basisPrice) and basisPrice > 0 ? exitPrice / basisPrice - 1 : na
        if not na(realized)
            equity := equity * (1 + realized)
        equityClosedSeries := equity
        lastSellPrice := exitPrice
        holdingChanged := true
        prevHeldLabel := exitLabel
        holdingIdx := na
        heldLabel := "未持仓"
        holdingWeeks := 0
        entryPrice := na
        // 强平后不再展示持仓盈亏
        holdingPnlSeries := na
        rebalancePriceSeries := exitPrice
        forceExitPending := false
        forceExitPendingIdx := na
        forceExitPendingDay := na
        forceExitPendingBasis := na
        forceExitExecuted := true
        string noteTxt = forceExitPendingNote
        forceExitPendingNote := ""
        // 标注强平（次日开盘执行）
        if showForceExitLabel
            string exitTimeTxt = formatDate(time)
            string exitModeTxt = "开盘"
            string exitLblTxt = str.format("强平 {0}\n时间: {1} {2}\n价格: {3}", exitLabel, exitTimeTxt, exitModeTxt, fmtPrice(exitPrice))
            label.new(bar_index, equity, exitLblTxt, color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.small)
        if enablePositionLog
            log.error(str.format("风险过滤清仓: {0} @ {1} {2}", exitLabel, fmtPrice(exitPrice), noteTxt))
        if enableEquityDebug
            log.error(str.format("最新净值: {0,number,#.##}", equityClosedSeries))

    // 调仓/强平结算：仅在换仓或清仓时结算净值
    if rebalanceConfirmed
        bool hadForceExitThisBar = forceExitExecuted
        prevHoldingIdx := holdingIdx
        prevHeldLabel := not na(prevHoldingIdx) ? array.get(labels, prevHoldingIdx) : "未持仓"
        hadPositionPrev := not na(prevHoldingIdx)
        prevHoldingWeeksMsg := holdingWeeks
        holdingChanged := false
        rebalancePriceSeries := na

        bool isDelayedRebalance = shouldRecordAfterMissedAnchor and skippedAnchorCount == 1

        // 保存旧仓信息(用于收盘换仓时计算回撤)
        if hadPositionPrev
            prevEntryPrice := entryPrice
            prevEntryEquity := entryEquity
        else
            prevEntryPrice := na
            prevEntryEquity := na

        // Determine next holding
        int weeksHeld = hadPositionPrev ? holdingWeeks + 1 : 0
        int nextIdx = bestIdx
        bool holdLockActive = hadPositionPrev and not na(nextIdx) and weeksHeld < minHoldWeeks and isSymbolEligible(prevHoldingIdx)
        if holdLockActive
            nextIdx := prevHoldingIdx
        bool hasCandidate = not na(nextIdx)
        switching := hadPositionPrev and hasCandidate and nextIdx != prevHoldingIdx
        exitingOnly := hadPositionPrev and not hasCandidate
        entering := hasCandidate and (not hadPositionPrev or switching)
        switchEvent := switching or entering or exitingOnly

        // 递增持仓周计数
        if hadPositionPrev and not switching and not exitingOnly
            holdingWeeks := weeksHeld

        // Realize only when exiting
        if switching or exitingOnly
            int exitIdx = prevHoldingIdx
            string exitSym = array.get(tickers, exitIdx)
            string exitLabel = array.get(labels, exitIdx)

            float exitPrice = na
            if isDelayedRebalance and useCloseRebalance
                exitPrice := roundPrice(request.security(exitSym, "D", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
            else
                exitPrice := roundPrice(request.security(exitSym, "D", useCloseRebalance ? close : open, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
            float basisPrice = entryPrice
            float realized = not na(exitPrice) and not na(basisPrice) and basisPrice > 0 ? exitPrice / basisPrice - 1 : na
            if not na(realized)
                equity := equity * (1 + realized)
                // stats per trade
                int statsIdx = exitIdx
                float prevMul = array.get(symCumReturn, statsIdx)
                array.set(symCumReturn, statsIdx, nz(prevMul, 1.0) * (1 + realized))
                int prevTrades = array.get(symTradeCount, statsIdx)
                array.set(symTradeCount, statsIdx, prevTrades + 1)
                if realized > 0
                    array.set(symWinCount, statsIdx, array.get(symWinCount, statsIdx) + 1)
                    array.set(symProfitSum, statsIdx, array.get(symProfitSum, statsIdx) + realized)
                else if realized < 0
                    array.set(symLossSum, statsIdx, array.get(symLossSum, statsIdx) + realized)
                sumWeeklyRet += realized
                sumWeeklyRetSq += realized * realized
                weeksCount += 1
            equityClosedSeries := equity
            lastSellPrice := exitPrice
            holdingWeeks := 0
        else
            // 持续持有，不结算，不改变净值
            equityClosedSeries := equity
            lastSellPrice := na

        // 开仓/换仓后的入场
        if entering
            float nextBuyPrice = na
            if isDelayedRebalance and useCloseRebalance
                nextBuyPrice := roundPrice(request.security(array.get(tickers, nextIdx), "D", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
            else
                nextBuyPrice := roundPrice(request.security(array.get(tickers, nextIdx), "D", useCloseRebalance ? close : open, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
            entryPrice := nextBuyPrice
            entryEquity := equity
            lastBuyPrice := nextBuyPrice
        else if exitingOnly
            entryPrice := na
            entryEquity := equity
            lastBuyPrice := na
        else
            lastBuyPrice := na

        // 仅在有成交价格时展示 rebalancePriceSeries
        rebalancePriceSeries := switching or entering ? entryPrice : (exitingOnly ? lastSellPrice : na)
        if not entering and not exitingOnly
            rebalancePriceSeries := na

        holdingIdx := hasCandidate ? nextIdx : na
        heldLabel := not na(holdingIdx) ? array.get(labels, holdingIdx) : "未持仓"
        holdingChanged := switchEvent or exitingOnly or entering

        // 记录历史价格(正常换仓执行后)
        int normalRecordTime = na
        for i = 0 to assetCount - 1
            string sym = array.get(tickers, i)

            // 数据来源选择
            float recordClose = na
            int recordTime = na
            if isAnchorDay
                recordClose := request.security(sym, "D", close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                recordTime := time
            else
                recordClose := request.security(sym, "D", close[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                recordTime := time[1]

            if i == 0
                normalRecordTime := recordTime

            shiftAnchorHistory(i, recordClose, recordTime)

        if enableAnchorRecordLog
            string dataSourceTxt = isAnchorDay ? "close" : "close[1]"
            // 正常换仓的目标锚点日：与记录用的anchor日期一致
            string targetAnchorDateTxt = na(normalRecordTime) ? "N/A" : formatDate(normalRecordTime)
            log.warning(str.format("正常换仓周锚点: 日期={0} 数据来源={1} 目标Anchor日={2}", formatDate(normalRecordTime), dataSourceTxt, targetAnchorDateTxt))

    else
        if not forceExitExecuted
            equityClosedSeries := nz(equityClosedSeries[1], initialCapital)
            rebalancePriceSeries := na
            holdingChanged := false
        switchEvent := false
        entering := false
        switching := false
        exitingOnly := false

    // === 回撤计算逻辑 ===
    // 1. 每次卖出(换仓/强平)后更新净值高点
    // 2. 根据持仓的日内低点计算日内最低净值
    // 3. 当前回撤 = (日内最低净值 - 净值高点) / 净值高点
    // 4. 收盘换仓:用旧仓计算完回撤后再换仓,新仓不计算换仓日回撤
    // 5. 开盘换仓:用新仓计算换仓日回撤

    // === 日线浮动净值计算 ===
    // 根据当前持仓的日线收盘价实时计算净值
    if not na(holdingIdx)
        string heldSymDaily = array.get(tickers, holdingIdx)
        float dailyClose = roundPrice(request.security(heldSymDaily, "D", close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
        if not na(dailyClose) and not na(entryPrice) and entryPrice > 0
            float dailyReturn = dailyClose / entryPrice - 1
            equityDailySeries := entryEquity * (1 + dailyReturn)
        else
            equityDailySeries := equityClosedSeries
    else
        equityDailySeries := equityClosedSeries

    // === 回撤计算（使用日线浮动净值的低点）===

    // 计算日内最低净值
    // 收盘换仓/开仓日:用旧仓计算回撤(首次开仓时旧仓为空,不计算回撤)
    float equityLowToday = equityClosedSeries  // 默认值为结算净值
    if forceExitExecuted
        // 当天发生强平: 不再显示持仓盈亏, 仅使用结算净值参与回撤计算
        holdingPnlSeries := na
    else if useCloseRebalance and rebalanceConfirmed
        if not na(prevHoldingIdx)
            // 有旧仓:用旧仓计算回撤
            string heldSymOld = array.get(tickers, prevHoldingIdx)
            float currCloseOld = roundPrice(request.security(heldSymOld, "D", close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
            float currLowOld = roundPrice(request.security(heldSymOld, "D", low, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))

            // 持仓盈亏(基于旧仓)
            holdingPnlSeries := not na(prevEntryPrice) and prevEntryPrice > 0 ? (currCloseOld / prevEntryPrice - 1) : na

            // 用旧仓日内低点计算最低净值
            if not na(currLowOld) and not na(prevEntryPrice) and prevEntryPrice > 0
                float lowReturn = currLowOld / prevEntryPrice - 1
                equityLowToday := prevEntryEquity * (1 + lowReturn)
        else
            // 首次开仓:不计算回撤
            holdingPnlSeries := na
    // 开盘换仓或非换仓日:用当前持仓计算
    else if not na(holdingIdx)
        string heldSym = array.get(tickers, holdingIdx)
        float currClose = roundPrice(request.security(heldSym, "D", close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
        float currLow = roundPrice(request.security(heldSym, "D", low, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))

        // 持仓盈亏百分比
        holdingPnlSeries := not na(entryPrice) and entryPrice > 0 ? (currClose / entryPrice - 1) : na

        // 计算日内最低净值
        if not na(currLow) and not na(entryPrice) and entryPrice > 0
            float lowReturn = currLow / entryPrice - 1
            equityLowToday := entryEquity * (1 + lowReturn)
    else
        // 无持仓
        holdingPnlSeries := na

    // 计算当前回撤
    if not na(peakEquity) and peakEquity > 0
        currentDrawdown := (equityLowToday - peakEquity) / peakEquity
    else
        currentDrawdown := 0.0

    // 更新最大回撤
    prevMaxDd = nz(maxDrawdownSeries[1], 0.0)
    bool isNewMaxDrawdown = currentDrawdown < prevMaxDd
    if isNewMaxDrawdown
        maxDrawdownSeries := currentDrawdown
    else
        maxDrawdownSeries := prevMaxDd

    // 回撤调试日志
    if enableDdDebug and barstate.isconfirmed and not na(currentDrawdown)
        if na(lastCurrentDdLog) or currentDrawdown != lastCurrentDdLog
            if currentDrawdown < 0
                // 获取触发最低净值的价格和持仓标签
                string lowPriceTxt = "N/A"
                string ddHoldingLabel = heldLabel
                if useCloseRebalance and rebalanceConfirmed and not na(prevHoldingIdx)
                    // 收盘换仓日,使用旧仓的日内低点和旧仓标签
                    string heldSymOld = array.get(tickers, prevHoldingIdx)
                    float currLowOld = roundPrice(request.security(heldSymOld, "D", low, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
                    lowPriceTxt := fmtPrice(currLowOld)
                    ddHoldingLabel := prevHeldLabel
                else if not na(holdingIdx)
                    // 其他情况使用当前持仓的日内低点
                    string heldSym = array.get(tickers, holdingIdx)
                    float currLow = roundPrice(request.security(heldSym, "D", low, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
                    lowPriceTxt := fmtPrice(currLow)
                    ddHoldingLabel := heldLabel

                if isNewMaxDrawdown
                    // 最大回撤创新高,使用error级别
                    log.error(str.format("当前回撤: {0,number,#.##}% | 最高净值: {1,number,#.##} | 回撤净值: {2,number,#.##} | 持仓: {3} | 低点价格: {4} | 刷新最大回撤", currentDrawdown * 100, peakEquity, equityLowToday, ddHoldingLabel, lowPriceTxt))
                else
                    // 普通回撤,使用warning级别
                    log.warning(str.format("当前回撤: {0,number,#.##}% | 最高净值: {1,number,#.##} | 回撤净值: {2,number,#.##} | 持仓: {3} | 低点价格: {4}", currentDrawdown * 100, peakEquity, equityLowToday, ddHoldingLabel, lowPriceTxt))
            lastCurrentDdLog := currentDrawdown

    // 在回撤计算完成后,更新净值高点(必须在回撤计算之后,避免使用更新后的高点计算当天回撤)
    if (switching or exitingOnly or forceExitExecuted) and barstate.isconfirmed
        if equityClosedSeries > peakEquity
            peakEquity := equityClosedSeries
            if enableEquityDebug
                log.warning(str.format("净值新高: {0,number,#.##}", equityClosedSeries))

    // 最大回撤标注
    if isNewMaxDrawdown and showMaxDdLabel
        if not na(maxDdLabel)
            label.delete(maxDdLabel)
        ddText = str.format("最大回撤刷新 {0,number,#.##}%", currentDrawdown * 100)
        maxDdLabel := label.new(bar_index, equityClosedSeries, ddText, color=color.new(color.maroon, 0), textcolor=color.white, style=label.style_label_down)
    else if not showMaxDdLabel and not na(maxDdLabel)
        label.delete(maxDdLabel)
        maxDdLabel := na

    // 这里开始继续原有换仓提示等逻辑

    // 调仓/持仓提示：确保回撤日志先输出
    if showSwitchRealtime or showSwitchConfirmed
        if not na(lastSwitch)
            label.delete(lastSwitch)
        string msg = ""
        bool isTrialEquityMsg = false
        if showSwitchConfirmed
            if switchEvent
                string sellTxt = na(lastSellPrice) ? "—" : fmtPrice(lastSellPrice)
                string buyTxt  = na(lastBuyPrice)  ? "—" : fmtPrice(lastBuyPrice)

                // 计算换仓时点文本
                string timingTxt = ""
                // 判断是否为“锚点日休市后的次日补换仓”（只有这种情况展示 [补换仓 目标/实际] 文案）
                bool isDelayedRebalanceForDisplay = shouldRecordAfterMissedAnchor and skippedAnchorCount == 1
                if isDelayedRebalanceForDisplay
                    // 补换仓：显示目标锚点日期、实际执行日期和换仓时点
                    int daysToAdd = weekAnchorDay - prevDayOfWeek
                    if daysToAdd < 0
                        daysToAdd := daysToAdd + 7
                    int calcMissedAnchorTime = time[1] + daysToAdd * 86400000
                    string actualDate = formatDate(time[1])  // 实际执行日(锚点周收盘日)
                    string targetDate = formatDate(calcMissedAnchorTime)  // 目标锚点日
                    string rebalanceTiming = useCloseRebalance ? "收盘" : "次日开盘"
                    timingTxt := str.format("[补换仓 目标:{0} 实际:{1} {2}]", targetDate, actualDate, rebalanceTiming)
                else
                    // 正常换仓
                    timingTxt := useCloseRebalance ? weekAnchor + "收盘" : weekAnchor + "次日开盘"

                if entering and not switching and not hadPositionPrev
                    msg := str.format("开仓[{0}]: {1}@{2}", timingTxt, heldLabel, buyTxt)
                else if exitingOnly
                    msg := str.format("平仓[{0}]: {1}@{2}", timingTxt, prevHeldLabel, sellTxt)
                else
                    msg := str.format("换仓[{0}]: {1}@{2} -> {3}@{4}", timingTxt, prevHeldLabel, sellTxt, heldLabel, buyTxt)
            else
                if prevHoldingWeeksMsg == 0
                    skipSwitchMsg := true
                else
                    string contLbl = not na(holdingIdx) ? array.get(labels, holdingIdx) : "未持仓"
                    float trialPx = roundPrice(request.security(array.get(tickers, holdingIdx), "D", useCloseRebalance ? close : open, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off))
                    float trialEquity = not na(trialPx) and not na(entryPrice) and entryPrice > 0 ? entryEquity * (trialPx / entryPrice) : na
                    string trialPxTxt = fmtPrice(trialPx)
                    string trialEqTxt = na(trialEquity) ? "N/A" : str.format("{0,number,#.##}", trialEquity)
                    string timingTxt = useCloseRebalance ? weekAnchor + "收盘" : weekAnchor + "次日开盘"
                    msg := str.format("继续持仓[{0}]: {1} | 价格 {2} | 浮动净值 {3}", timingTxt, contLbl, trialPxTxt, trialEqTxt)
                    isTrialEquityMsg := true
        else if previewSwitch
            string fromLbl = na(holdingIdx) ? "未持仓" : array.get(labels, holdingIdx)
            string toLbl = na(previewIdx) ? "未持仓" : array.get(labels, previewIdx)
            string timingTxt = useCloseRebalance ? weekAnchor + "收盘" : weekAnchor + "次日开盘"
            msg := str.format("预计换仓[{0}]: {1} -> {2}", timingTxt, fromLbl, toLbl)
        else if previewContinue
            string toLbl = array.get(labels, previewIdx)
            string timingTxt = useCloseRebalance ? weekAnchor + "收盘" : weekAnchor + "次日开盘"
            msg := str.format("预计继续持仓[{0}]: {1}", timingTxt, toLbl)
        else
            string timingTxt = useCloseRebalance ? weekAnchor + "收盘" : weekAnchor + "次日开盘"
            msg := str.format("预计持仓不变[{0}]", timingTxt)
        if not skipSwitchMsg and str.length(msg) > 0
            lastSwitch := label.new(bar_index, equityClosedSeries, msg, color=color.new(color.blue, 0), textcolor=color.white, style=label.style_label_up)
            alert(msg, alert.freq_once_per_bar)
            if isTrialEquityMsg
                if enableFloatingEquityDebug
                    log.warning(msg)
            else
                if enablePositionLog
                    log.error(msg)
                if enableEquityDebug
                    log.error(str.format("最新净值: {0,number,#.##}", equityClosedSeries))

    weekRetColor := nz(getColor(holdingIdx), color.orange)
    // Annualized return based on elapsed calendar time
    msPerYear = 365.25 * 24 * 60 * 60 * 1000.0
    elapsedYears = (time - backtestStart) / msPerYear
    annReturn := elapsedYears > 0 and initialCapital > 0 and equityClosedSeries > 0 ? math.pow(equityClosedSeries / initialCapital, 1.0 / elapsedYears) - 1 : na
    // Sharpe ratio using weekly returns accumulated
    meanRet = weeksCount > 0 ? sumWeeklyRet / weeksCount : na
    variance = weeksCount > 0 ? sumWeeklyRetSq / weeksCount - (meanRet * meanRet) : na
    variance := variance < 0 ? 0 : variance
    stdRet = not na(variance) ? math.sqrt(variance) : na
    sharpeAnnual := weeksCount > 1 and stdRet > 0 ? (meanRet / stdRet) * math.sqrt(52) : na

    // Update table display once per bar
    if barstate.islast
        table.cell(infoTable, 0, 0, "品种", text_color=color.white, bgcolor=color.new(color.blue, 40))
        table.cell(infoTable, 1, 0, str.format("{0}周涨幅", lookbackWeeks), text_color=color.white, bgcolor=color.new(color.blue, 40))
        table.cell(infoTable, 2, 0, "本周涨幅", text_color=color.white, bgcolor=color.new(color.blue, 40))
        table.cell(infoTable, 3, 0, str.format("{0}周收盘", lookbackWeeks), text_color=color.white, bgcolor=color.new(color.blue, 40))
        table.cell(infoTable, 4, 0, "周收盘", text_color=color.white, bgcolor=color.new(color.blue, 40))
        table.cell(infoTable, 5, 0, "累计盈亏", text_color=color.white, bgcolor=color.new(color.blue, 40))
        table.cell(infoTable, 6, 0, "胜率", text_color=color.white, bgcolor=color.new(color.blue, 40))
        table.cell(infoTable, 7, 0, "盈亏比", text_color=color.white, bgcolor=color.new(color.blue, 40))
        table.cell(infoTable, 8, 0, "过滤", text_color=color.white, bgcolor=color.new(color.blue, 40))
        sortTableRowsByMomentum()
        for rank = 0 to assetCount - 1
            row = rank + 1
            symIdx = array.get(displayOrder, rank)
            lbl = array.get(labels, symIdx)
            mom = array.get(momentum4w, symIdx)
            wret = array.get(weeklyRet, symIdx)
            cls = array.get(weeklyClose, symIdx)
            lbCls = array.get(lookbackClose, symIdx)
            isHeld = not na(holdingIdx) and holdingIdx == symIdx
            blocked = not isSymbolEligible(symIdx)
            bg = blocked ? color.new(color.gray, 80) : (isHeld ? color.new(color.orange, 50) : color.new(color.black, 0))
            text_color = isHeld ? color.new(color.black, 0) : color.new(color.white, 0)
            cumMul = array.get(symCumReturn, symIdx)
            tradesCnt = array.get(symTradeCount, symIdx)
            winsCnt = array.get(symWinCount, symIdx)
            profSum = array.get(symProfitSum, symIdx)
            lossSum = array.get(symLossSum, symIdx)
            totalPctSym = (nz(cumMul, 1.0) - 1) * 100
            winRateSym = tradesCnt > 0 ? winsCnt * 100.0 / tradesCnt : na
            profitFactor = lossSum < 0 ? profSum / math.abs(lossSum) : na
            table.cell(infoTable, 0, row, lbl, bgcolor=bg, text_color = text_color)
            table.cell(infoTable, 1, row, str.tostring(mom * 100, format.mintick) + "%", bgcolor=bg, text_color = text_color)
            table.cell(infoTable, 2, row, str.tostring(wret * 100, format.mintick) + "%", bgcolor=bg, text_color = text_color)
            table.cell(infoTable, 3, row, str.tostring(lbCls, format.mintick), bgcolor=bg, text_color = text_color)
            table.cell(infoTable, 4, row, str.tostring(cls, format.mintick), bgcolor=bg, text_color = text_color)
            table.cell(infoTable, 5, row, str.format("{0,number,#.##}%", totalPctSym), bgcolor=bg, text_color = text_color)
            table.cell(infoTable, 6, row, na(winRateSym) ? "N/A" : str.format("{0,number,#.##}%", winRateSym), bgcolor=bg, text_color = text_color)
            table.cell(infoTable, 7, row, na(profitFactor) ? "N/A" : str.tostring(profitFactor, format.mintick), bgcolor=bg, text_color = text_color)
            table.cell(infoTable, 8, row, blocked ? "停用" : "—", bgcolor=bg, text_color = text_color)
        startText = formatDate(backtestStart)
        endText = formatDate(backtestEnd)
        table.cell(ddTable, 0, 0, "指标", text_color=color.white, bgcolor=color.new(color.blue, 40))
        table.cell(ddTable, 1, 0, "数值", text_color=color.white, bgcolor=color.new(color.blue, 40))
        table.cell(ddTable, 0, 1, "最大回撤", bgcolor=color.new(color.black, 0), text_color=color.white)
        table.cell(ddTable, 1, 1, str.format("{0,number,#.##}%", maxDrawdownSeries * 100), text_color=color.red)
        table.cell(ddTable, 0, 2, "最终净值", bgcolor=color.new(color.black, 0), text_color=color.white)
        table.cell(ddTable, 1, 2, str.format("{0,number,#.##}", nz(equity, 0)), text_color=color.green)
        table.cell(ddTable, 0, 3, "回测范围", bgcolor=color.new(color.black, 0), text_color=color.white)
        table.cell(ddTable, 1, 3, str.format("{0} 至 {1}", startText, endText), text_color=color.black)
        table.cell(ddTable, 0, 4, "年化收益率", bgcolor=color.new(color.black, 0), text_color=color.white)
        table.cell(ddTable, 1, 4, na(annReturn) ? "N/A" : str.format("{0,number,#.##}%", annReturn * 100), text_color=color.black)
        table.cell(ddTable, 0, 5, "夏普比率(年化)", bgcolor=color.new(color.black, 0), text_color=color.white)
        table.cell(ddTable, 1, 5, na(sharpeAnnual) ? "N/A" : str.tostring(sharpeAnnual, format.mintick), text_color=color.black)
else
    holdingIdx := na
    heldLabel := "未持仓"
    entryPrice := na
    holdingWeeks := 0

plot(equityClosedSeries, title="Simulated Equity", color=color.teal, linewidth=2)
plot(equityDailySeries, title="Daily Trial Equity", color=color.new(color.gray, 0), linewidth=1, style=plot.style_line, display=display.all)
plot(currentDrawdown < 0 ? currentDrawdown * 100 : na, title="Current Drawdown (%)", color=color.new(color.red, 70), linewidth=1, style=plot.style_area, display=display.all, format=format.price, precision=2)
plot(maxDrawdownSeries * 100, title="Max Drawdown To Date (%)", color=color.new(color.red, 40), linewidth=1, style=plot.style_stepline, display=display.all, format=format.price, precision=2)
plot(holdingPnlSeries * 100, title="Holding PnL (%)", color=weekRetColor, style=plot.style_columns)

firstWeekMarkerNeeded = inRange and not firstWeekMarkerDone and rebalanceConfirmed
showSwitchMarker = rebalanceConfirmed and (holdingChanged or firstWeekMarkerNeeded)
plotchar(showSwitchMarker and holdingIdx >= 0, title="Holding This Week", char="●", location=location.bottom, color=weekRetColor, size=size.tiny)
if showSwitchMarker and inRange
    firstWeekMarkerDone := true
plot(rebalancePriceSeries, title="Rebalance Price", color=weekRetColor, display=display.status_line)
