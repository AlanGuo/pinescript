//@version=6
strategy("Dragon Breakout", shorttitle="Breakout", overlay=true, initial_capital = 10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)

// ==================== Input Parameters ====================

// Moving Average Settings
ma_type = input.string("SMA", "MA Type", options=["SMA", "EMA"], group="Moving Average Settings")
ma_period_1 = input.int(25, "MA Period 1", minval=1, group="Moving Average Settings")
ma_period_2 = input.int(50, "MA Period 2", minval=1, group="Moving Average Settings")
ma_period_3 = input.int(100, "MA Period 3", minval=1, group="Moving Average Settings")
ma_period_4 = input.int(150, "MA Period 4", minval=1, group="Moving Average Settings")
ma_period_5 = input.int(300, "MA Period 5", minval=1, group="Moving Average Settings")
min_cross_count = input.int(3, "Min Cross Count", minval=1, maxval=5, group="Moving Average Settings")

// Volume and Body Settings
volume_lookback = input.int(20, "Volume Lookback", minval=1, group="Volume and Body")
volume_min_ratio = input.float(1.2, "Min Volume Ratio", minval=1.0, step=0.1, group="Volume and Body")
body_lookback = input.int(20, "Body Lookback", minval=1, group="Volume and Body")

// Retest Settings
breakout_lookback = input.int(15, "Breakout Lookback", minval=1, group="Retest Settings")
retest_window = input.int(5, "Retest Window", minval=1, group="Retest Settings")
retest_body_ratio = input.float(0.5, "Retest Body Ratio", minval=0.0, maxval=1.0, step=0.1, group="Retest Settings")

// Backtest Settings
enable_backtest = input.bool(true, "Enable Backtest", group="Backtest Settings")
min_score_threshold = input.float(0.8, "Min Score Threshold", minval=0.0, step=0.1, group="Backtest Settings")
start_date = input.time(timestamp("2017-01-01 00:00"), "Backtest Start Date", group="Backtest Settings")
end_date = input.time(timestamp("2099-01-01 00:00"), "Backtest End Date", group="Backtest Settings")
exit_ma_option = input.string("MA 1", "Exit MA", options=["None", "MA 1", "MA 2", "MA 3", "MA 4", "MA 5"], group="Backtest Settings")

// Visualization Settings
show_mas = input.bool(true, "Show MAs", group="Visualization")
show_breakout_markers = input.bool(true, "Show Breakout Markers", group="Visualization")
show_retest_levels = input.bool(true, "Show Retest Levels", group="Visualization")
show_score = input.bool(true, "Show Score", group="Visualization")

// ==================== Base Indicator Calculation ====================

// Calculate Moving Averages
var ma_periods = array.from(ma_period_1, ma_period_2, ma_period_3, ma_period_4, ma_period_5)
var int total_ma = array.size(ma_periods)

f_get_ma(src, period) =>
    ma_type == "EMA" ? ta.ema(src, period) : ta.sma(src, period)

ma_1 = f_get_ma(close, ma_period_1)
ma_2 = f_get_ma(close, ma_period_2)
ma_3 = f_get_ma(close, ma_period_3)
ma_4 = f_get_ma(close, ma_period_4)
ma_5 = f_get_ma(close, ma_period_5)

// Store all MAs in array for iteration
var ma_values = array.new_float(5)
array.set(ma_values, 0, ma_1)
array.set(ma_values, 1, ma_2)
array.set(ma_values, 2, ma_3)
array.set(ma_values, 3, ma_4)
array.set(ma_values, 4, ma_5)

// Calculate cross_count
// Cross condition: open < MA AND close > MA
cross_count = 0
min_crossed_ma = float(na)
max_crossed_ma = float(na)

for i = 0 to total_ma - 1
    ma_val = array.get(ma_values, i)
    if not na(ma_val) and open < ma_val and close > ma_val
        cross_count += 1
        min_crossed_ma := na(min_crossed_ma) ? ma_val : math.min(min_crossed_ma, ma_val)
        max_crossed_ma := na(max_crossed_ma) ? ma_val : math.max(max_crossed_ma, ma_val)

// Calculate volume_ratio
volume_mean = ta.sma(volume, volume_lookback)
volume_ratio = volume_mean > 0 ? volume / volume_mean : na

// Calculate body_ratio
body_size = math.abs(close - open)
body_mean = ta.sma(body_size, body_lookback)
body_ratio = body_mean > 0 ? body_size / body_mean : na

// ==================== Breakout Detection ====================

// Detect dragon_breakout_flag
is_bullish = close > open
base_valid = cross_count >= min_cross_count and not na(volume_ratio) and not na(body_ratio)

full_range_condition = is_bullish and
                       not na(min_crossed_ma) and
                       not na(max_crossed_ma) and
                       open <= min_crossed_ma and
                       close >= max_crossed_ma

dragon_breakout_flag = base_valid and
                       full_range_condition and
                       cross_count >= min_cross_count and
                       volume_ratio >= volume_min_ratio ? 1.0 : 0.0

// ==================== Retest Monitoring ====================

// Variables to store breakout information
var float breakout_bar_index = na
var float breakout_open = na
var float breakout_close = na
var float breakout_cross_count = na
var float breakout_volume_ratio = na
var float breakout_body_ratio = na
var float pullback_threshold = na
var bool retest_success = false
var bool retest_invalidated = false

// Find the most recent breakout
if dragon_breakout_flag == 1.0
    breakout_bar_index := bar_index
    breakout_open := open
    breakout_close := close
    breakout_cross_count := cross_count
    breakout_volume_ratio := volume_ratio
    breakout_body_ratio := body_ratio

    // Calculate pullback threshold
    body_height = math.abs(breakout_close - breakout_open)
    pullback_threshold := breakout_open + body_height * retest_body_ratio

    // Reset retest state
    retest_success := false
    retest_invalidated := false

// Monitor retest
if not na(breakout_bar_index)
    bars_since_breakout = bar_index - breakout_bar_index

    if bars_since_breakout > 0 and bars_since_breakout <= retest_window and not retest_success and not retest_invalidated
        // Get the minimum crossed MA from breakout candle
        // Simplified: use current min_crossed_ma as reference
        reference_ma = ma_1  // Can be optimized to actual min crossed MA

        // Detect successful retest: low touches threshold but close holds
        if low <= pullback_threshold and close >= math.min(breakout_close, reference_ma)
            retest_success := true

        // Detect invalidated: close below threshold
        if close < pullback_threshold
            retest_invalidated := true

// ==================== Scoring System ====================

// Calculate base score
float base_score = 0.0

if not na(breakout_bar_index)
    bars_since = bar_index - breakout_bar_index

    if bars_since <= breakout_lookback
        // Calculate cross score
        cross_score = breakout_cross_count / total_ma

        // Calculate volume factor
        volume_factor = math.max(breakout_volume_ratio - 1.0, 0.0)

        // Calculate body factor
        body_factor = math.max(breakout_body_ratio - 1.0, 0.0)

        // Base score
        base_value = cross_score * (1.0 + 0.6 * volume_factor + 0.4 * body_factor)

        // Retest modifier
        retest_factor = retest_success ? 1.25 : (retest_invalidated ? 0.6 : 1.0)

        // Time decay factor (assuming 1 bar = 1 day, may need adjustment based on timeframe)
        days_since = bars_since  // Simplified
        decay_factor = math.max(0.4, 1.0 - 0.08 * days_since)

        // Final score
        base_score := math.max(base_value * retest_factor * decay_factor, 0.0)

// ==================== Exit Signal Calculation ====================

// Get exit MA value based on selection
exit_ma = exit_ma_option == "MA 1" ? ma_1 :
          exit_ma_option == "MA 2" ? ma_2 :
          exit_ma_option == "MA 3" ? ma_3 :
          exit_ma_option == "MA 4" ? ma_4 :
          exit_ma_option == "MA 5" ? ma_5 : float(na)

// Check if close breaks below exit MA
ma_exit_signal = exit_ma_option != "None" and not na(exit_ma) and close < exit_ma

// ==================== Visualization ====================

// Plot Moving Averages
plot(show_mas ? ma_1 : na, "MA 1", color=color.new(color.blue, 0), linewidth=1, linestyle = plot.linestyle_dashed)
plot(show_mas ? ma_2 : na, "MA 2", color=color.new(color.orange, 0), linewidth=1, linestyle = plot.linestyle_dashed)
plot(show_mas ? ma_3 : na, "MA 3", color=color.new(color.green, 0), linewidth=1, linestyle = plot.linestyle_dashed)
plot(show_mas ? ma_4 : na, "MA 4", color=color.new(color.red, 0), linewidth=1, linestyle = plot.linestyle_dashed)
plot(show_mas ? ma_5 : na, "MA 5", color=color.new(color.purple, 0), linewidth=1, linestyle = plot.linestyle_dashed)

// Mark breakout points
plotshape(show_breakout_markers and dragon_breakout_flag == 1.0,
          "Breakout",
          shape.triangleup,
          location.belowbar,
          color.new(color.green, 0),
          text="BO",
          size=size.small)

// Plot pullback threshold line
plot(show_retest_levels and not na(pullback_threshold) and bar_index - breakout_bar_index <= retest_window ? pullback_threshold : na,
     "Retest Level",
     color=color.new(color.black, 0),
     linewidth=2,
     style=plot.style_linebr)

// Mark successful retest
plotshape(show_retest_levels and retest_success and retest_success[1] == false,
          "Retest Success",
          shape.circle,
          location.belowbar,
          color.new(color.blue, 0),
          text="RT",
          size=size.tiny)

// Mark invalidated retest
plotshape(show_retest_levels and retest_invalidated and retest_invalidated[1] == false,
          "Retest Failed",
          shape.xcross,
          location.belowbar,
          color.new(color.red, 0),
          text="X",
          size=size.tiny)

// Mark MA exit signal
plotshape(ma_exit_signal and strategy.position_size > 0,
          "MA Exit",
          shape.triangledown,
          location.abovebar,
          color.new(color.orange, 0),
          text="MA",
          size=size.tiny)

// Show score via background color
bgcolor(show_score and base_score > 0 ? color.new(base_score >= min_score_threshold ? color.green : color.yellow, 90) : na)

// Display detailed info on breakout candle
if show_breakout_markers and dragon_breakout_flag == 1.0
    label.new(bar_index, high,
              "Breakout\nCross:" + str.tostring(cross_count) + "\nVol:" + str.tostring(volume_ratio, "#.##") + "\nBody:" + str.tostring(body_ratio, "#.##"),
              style=label.style_label_down,
              color=color.new(color.green, 20),
              textcolor=color.white,
              size=size.small)

// ==================== Strategy Trading ====================

// Time filter
in_backtest_period = true

if enable_backtest and in_backtest_period
    // Entry condition: score meets threshold
    if base_score >= min_score_threshold and strategy.position_size == 0
        strategy.entry("Long", strategy.long)

    // Exit conditions:
    // 1. Score below threshold
    // if base_score < min_score_threshold
    //     strategy.close("Long", comment="Score Low")
    // 2. Retest invalidated
    // 3. Close breaks below selected MA
    if strategy.position_size > 0
        if retest_invalidated
            strategy.close("Long", comment="Retest Failed")
        else if ma_exit_signal
            strategy.close("Long", comment="MA Break")

// Close position if outside backtest period
if strategy.position_size > 0 and not in_backtest_period
    strategy.close("Long", comment="Period End")

// ==================== Plot Score Indicator (Sub-chart) ====================

// Plot indicators in status line
plot(body_ratio, "Body Ratio", color=color.new(color.orange, 0), linewidth=1, display=display.status_line)
plot(volume_ratio, "Volume Ratio", color=color.new(color.green, 0), linewidth=1, display=display.status_line)
plot(cross_count, "Cross Count", color=color.new(color.red, 0), linewidth=1, display=display.status_line)
plot(base_score, "Score", color=color.new(color.blue, 0), linewidth=2, display=display.status_line)
